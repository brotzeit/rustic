Enum Option

* Enum std::option::Option

#+BEGIN_SRC rust 
pub enum Option<T> {
    None,
    Some(T),
}
#+END_SRC

The =Option= type. See the module level documentation for more.

* Variants

** =None=

No value

** =Some(T)=

Some value =T=

* Implementations

** =impl<T> Option<T>=

*** =pub fn is_some(&self) -> bool=

if you intended to assert that this has a value, consider `.unwrap()` instead

Returns =true= if the option is a =Some= value.

#+BEGIN_SRC rust 
let x: Option<u32> = Some(2);
assert_eq!(x.is_some(), true);

let x: Option<u32> = None;
assert_eq!(x.is_some(), false);
#+END_SRC

*** =pub fn is_none(&self) -> bool=

if you intended to assert that this doesn't have a value, consider \                   `.and_then(|| panic!(\"`Option` had a value when expected `None`\"))` instead

Returns =true= if the option is a =None= value.

#+BEGIN_SRC rust 
let x: Option<u32> = Some(2);
assert_eq!(x.is_none(), false);

let x: Option<u32> = None;
assert_eq!(x.is_none(), true);
#+END_SRC

*** =pub fn contains<U>(&self, x: &U) -> bool where    U: PartialEq<T>, =

This is a nightly-only experimental API.
(=option_result_contains= #62358)

Returns =true= if the option is a =Some= value containing the given
value.

#+BEGIN_SRC rust 
#![feature(option_result_contains)]

let x: Option<u32> = Some(2);
assert_eq!(x.contains(&2), true);

let x: Option<u32> = Some(3);
assert_eq!(x.contains(&2), false);

let x: Option<u32> = None;
assert_eq!(x.contains(&2), false);
#+END_SRC

*** =pub fn as_ref(&self) -> Option<&T>=

Converts from =&Option<T>= to =Option<&T>=.

Converts an =Option<==String==>= into an =Option<==usize==>=, preserving
the original. The =map= method takes the =self= argument by value,
consuming the original, so this technique uses =as_ref= to first take an
=Option= to a reference to the value inside the original.

#+BEGIN_SRC rust 
let text: Option<String> = Some("Hello, world!".to_string());
// First, cast `Option<String>` to `Option<&String>` with `as_ref`,
// then consume *that* with `map`, leaving `text` on the stack.
let text_length: Option<usize> = text.as_ref().map(|s| s.len());
println!("still can print text: {:?}", text);
#+END_SRC

*** =pub fn as_mut(&mut self) -> Option<&mut T>=

Converts from =&mut Option<T>= to =Option<&mut T>=.

#+BEGIN_SRC rust 
let mut x = Some(2);
match x.as_mut() {
    Some(v) => *v = 42,
    None => {},
}
assert_eq!(x, Some(42));
#+END_SRC

*** =pub fn as_pin_ref(self: Pin<&Option<T>>) -> Option<Pin<&T>>=

Converts from =Pin==<&Option<T>>= to =Option<==Pin==<&T>>=.

*** =pub fn as_pin_mut(self: Pin<&mut Option<T>>) -> Option<Pin<&mut T>>=

Converts from =Pin==<&mut Option<T>>= to =Option<==Pin==<&mut T>>=.

*** =pub fn expect(self, msg: &str) -> T=

Returns the contained =Some= value, consuming the =self= value.

Panics if the value is a =None= with a custom panic message provided by
=msg=.

#+BEGIN_SRC rust 
let x = Some("value");
assert_eq!(x.expect("fruits are healthy"), "value");
#+END_SRC

#+BEGIN_SRC rust 
let x: Option<&str> = None;
x.expect("fruits are healthy"); // panics with `fruits are healthy`
#+END_SRC

*** =pub fn unwrap(self) -> T=

Returns the contained =Some= value, consuming the =self= value.

Because this function may panic, its use is generally discouraged.
Instead, prefer to use pattern matching and handle the =None= case
explicitly, or call =unwrap_or=, =unwrap_or_else=, or
=unwrap_or_default=.

Panics if the self value equals =None=.

#+BEGIN_SRC rust 
let x = Some("air");
assert_eq!(x.unwrap(), "air");
#+END_SRC

#+BEGIN_SRC rust 
let x: Option<&str> = None;
assert_eq!(x.unwrap(), "air"); // fails
#+END_SRC

*** =pub fn unwrap_or(self, default: T) -> T=

Returns the contained =Some= value or a provided default.

Arguments passed to =unwrap_or= are eagerly evaluated; if you are
passing the result of a function call, it is recommended to use
=unwrap_or_else=, which is lazily evaluated.

#+BEGIN_SRC rust 
assert_eq!(Some("car").unwrap_or("bike"), "car");
assert_eq!(None.unwrap_or("bike"), "bike");
#+END_SRC

*** =pub fn unwrap_or_else<F>(self, f: F) -> T where    F: FnOnce() -> T, =

Returns the contained =Some= value or computes it from a closure.

#+BEGIN_SRC rust 
let k = 10;
assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);
assert_eq!(None.unwrap_or_else(|| 2 * k), 20);
#+END_SRC

*** =pub fn map<U, F>(self, f: F) -> Option<U> where    F: FnOnce(T) -> U, =

Maps an =Option<T>= to =Option<U>= by applying a function to a contained
value.

Converts an =Option<==String==>= into an =Option<==usize==>=, consuming
the original:

#+BEGIN_SRC rust 
let maybe_some_string = Some(String::from("Hello, World!"));
// `Option::map` takes self *by value*, consuming `maybe_some_string`
let maybe_some_len = maybe_some_string.map(|s| s.len());

assert_eq!(maybe_some_len, Some(13));
#+END_SRC

*** =pub fn map_or<U, F>(self, default: U, f: F) -> U where    F: FnOnce(T) -> U, =

Applies a function to the contained value (if any), or returns the
provided default (if not).

Arguments passed to =map_or= are eagerly evaluated; if you are passing
the result of a function call, it is recommended to use =map_or_else=,
which is lazily evaluated.

#+BEGIN_SRC rust 
let x = Some("foo");
assert_eq!(x.map_or(42, |v| v.len()), 3);

let x: Option<&str> = None;
assert_eq!(x.map_or(42, |v| v.len()), 42);
#+END_SRC

*** =pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U where    D: FnOnce() -> U,    F: FnOnce(T) -> U, =

Applies a function to the contained value (if any), or computes a
default (if not).

#+BEGIN_SRC rust 
let k = 21;

let x = Some("foo");
assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);

let x: Option<&str> = None;
assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);
#+END_SRC

*** =pub fn ok_or<E>(self, err: E) -> Result<T, E>=

Transforms the =Option<T>= into a =Result<T, E>=, mapping =Some(v)= to
=Ok(v)= and =None= to =Err(err)=.

Arguments passed to =ok_or= are eagerly evaluated; if you are passing
the result of a function call, it is recommended to use =ok_or_else=,
which is lazily evaluated.

#+BEGIN_SRC rust 
let x = Some("foo");
assert_eq!(x.ok_or(0), Ok("foo"));

let x: Option<&str> = None;
assert_eq!(x.ok_or(0), Err(0));
#+END_SRC

*** =pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E> where    F: FnOnce() -> E, =

Transforms the =Option<T>= into a =Result<T, E>=, mapping =Some(v)= to
=Ok(v)= and =None= to =Err(err())=.

#+BEGIN_SRC rust 
let x = Some("foo");
assert_eq!(x.ok_or_else(|| 0), Ok("foo"));

let x: Option<&str> = None;
assert_eq!(x.ok_or_else(|| 0), Err(0));
#+END_SRC

*** =pub fn iter(&self) -> Iter<T>=

Returns an iterator over the possibly contained value.

#+BEGIN_SRC rust 
let x = Some(4);
assert_eq!(x.iter().next(), Some(&4));

let x: Option<u32> = None;
assert_eq!(x.iter().next(), None);
#+END_SRC

*** =pub fn iter_mut(&mut self) -> IterMut<T>=

Returns a mutable iterator over the possibly contained value.

#+BEGIN_SRC rust 
let mut x = Some(4);
match x.iter_mut().next() {
    Some(v) => *v = 42,
    None => {},
}
assert_eq!(x, Some(42));

let mut x: Option<u32> = None;
assert_eq!(x.iter_mut().next(), None);
#+END_SRC

*** =pub fn and<U>(self, optb: Option<U>) -> Option<U>=

Returns =None= if the option is =None=, otherwise returns =optb=.

#+BEGIN_SRC rust 
let x = Some(2);
let y: Option<&str> = None;
assert_eq!(x.and(y), None);

let x: Option<u32> = None;
let y = Some("foo");
assert_eq!(x.and(y), None);

let x = Some(2);
let y = Some("foo");
assert_eq!(x.and(y), Some("foo"));

let x: Option<u32> = None;
let y: Option<&str> = None;
assert_eq!(x.and(y), None);
#+END_SRC

*** =pub fn and_then<U, F>(self, f: F) -> Option<U> where    F: FnOnce(T) -> Option<U>, =

Returns =None= if the option is =None=, otherwise calls =f= with the
wrapped value and returns the result.

Some languages call this operation flatmap.

#+BEGIN_SRC rust 
fn sq(x: u32) -> Option<u32> { Some(x * x) }
fn nope(_: u32) -> Option<u32> { None }

assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));
assert_eq!(Some(2).and_then(sq).and_then(nope), None);
assert_eq!(Some(2).and_then(nope).and_then(sq), None);
assert_eq!(None.and_then(sq).and_then(sq), None);
#+END_SRC

*** =pub fn filter<P>(self, predicate: P) -> Option<T> where    P: FnOnce(&T) -> bool, =

Returns =None= if the option is =None=, otherwise calls =predicate= with
the wrapped value and returns:

- =Some(t)= if =predicate= returns =true= (where =t= is the wrapped
  value), and
- =None= if =predicate= returns =false=.

This function works similar to =Iterator::filter()=. You can imagine the
=Option<T>= being an iterator over one or zero elements. =filter()= lets
you decide which elements to keep.

#+BEGIN_SRC rust 
fn is_even(n: &i32) -> bool {
    n % 2 == 0
}

assert_eq!(None.filter(is_even), None);
assert_eq!(Some(3).filter(is_even), None);
assert_eq!(Some(4).filter(is_even), Some(4));
#+END_SRC

*** =pub fn or(self, optb: Option<T>) -> Option<T>=

Returns the option if it contains a value, otherwise returns =optb=.

Arguments passed to =or= are eagerly evaluated; if you are passing the
result of a function call, it is recommended to use =or_else=, which is
lazily evaluated.

#+BEGIN_SRC rust 
let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));

let x = Some(2);
let y = Some(100);
assert_eq!(x.or(y), Some(2));

let x: Option<u32> = None;
let y = None;
assert_eq!(x.or(y), None);
#+END_SRC

*** =pub fn or_else<F>(self, f: F) -> Option<T> where    F: FnOnce() -> Option<T>, =

Returns the option if it contains a value, otherwise calls =f= and
returns the result.

#+BEGIN_SRC rust 
fn nobody() -> Option<&'static str> { None }
fn vikings() -> Option<&'static str> { Some("vikings") }

assert_eq!(Some("barbarians").or_else(vikings), Some("barbarians"));
assert_eq!(None.or_else(vikings), Some("vikings"));
assert_eq!(None.or_else(nobody), None);
#+END_SRC

*** =pub fn xor(self, optb: Option<T>) -> Option<T>=

Returns =Some= if exactly one of =self=, =optb= is =Some=, otherwise
returns =None=.

#+BEGIN_SRC rust 
let x = Some(2);
let y: Option<u32> = None;
assert_eq!(x.xor(y), Some(2));

let x: Option<u32> = None;
let y = Some(2);
assert_eq!(x.xor(y), Some(2));

let x = Some(2);
let y = Some(2);
assert_eq!(x.xor(y), None);

let x: Option<u32> = None;
let y: Option<u32> = None;
assert_eq!(x.xor(y), None);
#+END_SRC

*** =pub fn get_or_insert(&mut self, v: T) -> &mut T=

Inserts =v= into the option if it is =None=, then returns a mutable
reference to the contained value.

#+BEGIN_SRC rust 
let mut x = None;

{
    let y: &mut u32 = x.get_or_insert(5);
    assert_eq!(y, &5);

    *y = 7;
}

assert_eq!(x, Some(7));
#+END_SRC

*** =pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T where    F: FnOnce() -> T, =

Inserts a value computed from =f= into the option if it is =None=, then
returns a mutable reference to the contained value.

#+BEGIN_SRC rust 
let mut x = None;

{
    let y: &mut u32 = x.get_or_insert_with(|| 5);
    assert_eq!(y, &5);

    *y = 7;
}

assert_eq!(x, Some(7));
#+END_SRC

*** =pub fn take(&mut self) -> Option<T>=

Takes the value out of the option, leaving a =None= in its place.

#+BEGIN_SRC rust 
let mut x = Some(2);
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, Some(2));

let mut x: Option<u32> = None;
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, None);
#+END_SRC

*** =pub fn replace(&mut self, value: T) -> Option<T>=

Replaces the actual value in the option by the value given in parameter,
returning the old value if present, leaving a =Some= in its place
without deinitializing either one.

#+BEGIN_SRC rust 
let mut x = Some(2);
let old = x.replace(5);
assert_eq!(x, Some(5));
assert_eq!(old, Some(2));

let mut x = None;
let old = x.replace(3);
assert_eq!(x, Some(3));
assert_eq!(old, None);
#+END_SRC

*** =pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)>=

This is a nightly-only experimental API. (=option_zip= #70086)

Zips =self= with another =Option=.

If =self= is =Some(s)= and =other= is =Some(o)=, this method returns
=Some((s, o))=. Otherwise, =None= is returned.

#+BEGIN_SRC rust 
#![feature(option_zip)]
let x = Some(1);
let y = Some("hi");
let z = None::<u8>;

assert_eq!(x.zip(y), Some((1, "hi")));
assert_eq!(x.zip(z), None);
#+END_SRC

*** =pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R> where    F: FnOnce(T, U) -> R, =

This is a nightly-only experimental API. (=option_zip= #70086)

Zips =self= and another =Option= with function =f=.

If =self= is =Some(s)= and =other= is =Some(o)=, this method returns
=Some(f(s, o))=. Otherwise, =None= is returned.

#+BEGIN_SRC rust 
#![feature(option_zip)]

#[derive(Debug, PartialEq)]
struct Point {
    x: f64,
    y: f64,
}

impl Point {
    fn new(x: f64, y: f64) -> Self {
        Self { x, y }
    }
}

let x = Some(17.5);
let y = Some(42.7);

assert_eq!(x.zip_with(y, Point::new), Some(Point { x: 17.5, y: 42.7 }));
assert_eq!(x.zip_with(None, Point::new), None);
#+END_SRC

** =impl<'_, T> Option<&'_ T> where    T: Copy, =

*** =pub fn copied(self) -> Option<T>=

Maps an =Option<&T>= to an =Option<T>= by copying the contents of the
option.

#+BEGIN_SRC rust 
let x = 12;
let opt_x = Some(&x);
assert_eq!(opt_x, Some(&12));
let copied = opt_x.copied();
assert_eq!(copied, Some(12));
#+END_SRC

** =impl<'_, T> Option<&'_ mut T> where    T: Copy, =

*** =pub fn copied(self) -> Option<T>=

Maps an =Option<&mut T>= to an =Option<T>= by copying the contents of
the option.

#+BEGIN_SRC rust 
let mut x = 12;
let opt_x = Some(&mut x);
assert_eq!(opt_x, Some(&mut 12));
let copied = opt_x.copied();
assert_eq!(copied, Some(12));
#+END_SRC

** =impl<'_, T> Option<&'_ T> where    T: Clone, =

*** =pub fn cloned(self) -> Option<T>=

Maps an =Option<&T>= to an =Option<T>= by cloning the contents of the
option.

#+BEGIN_SRC rust 
let x = 12;
let opt_x = Some(&x);
assert_eq!(opt_x, Some(&12));
let cloned = opt_x.cloned();
assert_eq!(cloned, Some(12));
#+END_SRC

** =impl<'_, T> Option<&'_ mut T> where    T: Clone, =

*** =pub fn cloned(self) -> Option<T>=

Maps an =Option<&mut T>= to an =Option<T>= by cloning the contents of
the option.

#+BEGIN_SRC rust 
let mut x = 12;
let opt_x = Some(&mut x);
assert_eq!(opt_x, Some(&mut 12));
let cloned = opt_x.cloned();
assert_eq!(cloned, Some(12));
#+END_SRC

** =impl<T> Option<T> where    T: Debug, =

*** =pub fn expect_none(self, msg: &str)=

This is a nightly-only experimental API. (=option_expect_none= #62633)
newly added

Consumes =self= while expecting =None= and returning nothing.

Panics if the value is a =Some=, with a panic message including the
passed message, and the content of the =Some=.

#+BEGIN_SRC rust 
#![feature(option_expect_none)]

use std::collections::HashMap;
let mut squares = HashMap::new();
for i in -10..=10 {
    // This will not panic, since all keys are unique.
    squares.insert(i, i * i).expect_none("duplicate key");
}
#+END_SRC

#+BEGIN_SRC rust 
#![feature(option_expect_none)]

use std::collections::HashMap;
let mut sqrts = HashMap::new();
for i in -10..=10 {
    // This will panic, since both negative and positive `i` will
    // insert the same `i * i` key, returning the old `Some(i)`.
    sqrts.insert(i * i, i).expect_none("duplicate key");
}
#+END_SRC

*** =pub fn unwrap_none(self)=

This is a nightly-only experimental API. (=option_unwrap_none= #62633)
newly added

Consumes =self= while expecting =None= and returning nothing.

Panics if the value is a =Some=, with a custom panic message provided by
the =Some='s value.

#+BEGIN_SRC rust 
#![feature(option_unwrap_none)]

use std::collections::HashMap;
let mut squares = HashMap::new();
for i in -10..=10 {
    // This will not panic, since all keys are unique.
    squares.insert(i, i * i).unwrap_none();
}
#+END_SRC

#+BEGIN_SRC rust 
#![feature(option_unwrap_none)]

use std::collections::HashMap;
let mut sqrts = HashMap::new();
for i in -10..=10 {
    // This will panic, since both negative and positive `i` will
    // insert the same `i * i` key, returning the old `Some(i)`.
    sqrts.insert(i * i, i).unwrap_none();
}
#+END_SRC

** =impl<T> Option<T> where    T: Default, =

*** =pub fn unwrap_or_default(self) -> T=

Returns the contained =Some= value or a default

Consumes the =self= argument then, if =Some=, returns the contained
value, otherwise if =None=, returns the default value for that type.

Converts a string to an integer, turning poorly-formed strings into 0
(the default value for integers). =parse= converts a string to any other
type that implements =FromStr=, returning =None= on error.

#+BEGIN_SRC rust 
let good_year_from_input = "1909";
let bad_year_from_input = "190blarg";
let good_year = good_year_from_input.parse().ok().unwrap_or_default();
let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();

assert_eq!(1909, good_year);
assert_eq!(0, bad_year);
#+END_SRC

** =impl<T> Option<T> where    T: Deref, =

*** =pub fn as_deref(&self) -> Option<&<T as Deref>::Target>=

Converts from =Option<T>= (or =&Option<T>=) to =Option<&T::Target>=.

Leaves the original Option in-place, creating a new one with a reference
to the original one, additionally coercing the contents via =Deref=.

#+BEGIN_SRC rust 
let x: Option<String> = Some("hey".to_owned());
assert_eq!(x.as_deref(), Some("hey"));

let x: Option<String> = None;
assert_eq!(x.as_deref(), None);
#+END_SRC

** =impl<T> Option<T> where    T: DerefMut, =

*** =pub fn as_deref_mut(&mut self) -> Option<&mut <T as Deref>::Target>=

Converts from =Option<T>= (or =&mut Option<T>=) to
=Option<&mut T::Target>=.

Leaves the original =Option= in-place, creating a new one containing a
mutable reference to the inner type's =Deref::Target= type.

#+BEGIN_SRC rust 
let mut x: Option<String> = Some("hey".to_owned());
assert_eq!(x.as_deref_mut().map(|x| {
    x.make_ascii_uppercase();
    x
}), Some("HEY".to_owned().as_mut_str()));
#+END_SRC

** =impl<T, E> Option<Result<T, E>>=

*** =pub fn transpose(self) -> Result<Option<T>, E>=

Transposes an =Option= of a =Result= into a =Result= of an =Option=.

=None= will be mapped to =Ok==(==None==)=. =Some==(==Ok==(_))= and
=Some==(==Err==(_))= will be mapped to =Ok==(==Some==(_))= and
=Err==(_)=.

#+BEGIN_SRC rust 
#[derive(Debug, Eq, PartialEq)]
struct SomeErr;

let x: Result<Option<i32>, SomeErr> = Ok(Some(5));
let y: Option<Result<i32, SomeErr>> = Some(Ok(5));
assert_eq!(x, y.transpose());
#+END_SRC

** =impl<T> Option<Option<T>>=

*** =pub fn flatten(self) -> Option<T>=

Converts from =Option<Option<T>>= to =Option<T>=

Basic usage:

#+BEGIN_SRC rust 
let x: Option<Option<u32>> = Some(Some(6));
assert_eq!(Some(6), x.flatten());

let x: Option<Option<u32>> = Some(None);
assert_eq!(None, x.flatten());

let x: Option<Option<u32>> = None;
assert_eq!(None, x.flatten());
#+END_SRC

Flattening once only removes one level of nesting:

#+BEGIN_SRC rust 
let x: Option<Option<Option<u32>>> = Some(Some(Some(6)));
assert_eq!(Some(Some(6)), x.flatten());
assert_eq!(Some(6), x.flatten().flatten());
#+END_SRC

* Trait

** =impl<T> Clone for Option<T> where    T: Clone, =

=fn clone(&self) -> Option<T>= 

Returns a copy of the value. Read more

=fn clone_from(&mut self, source: &Option<T>)= 

Performs copy-assignment from =source=. Read more

** =impl<T> Copy for Option<T> where    T: Copy, =

** =impl<T> Debug for Option<T> where    T: Debug, =

=fn fmt(&self, f: &mut Formatter) -> Result<(), Error>= 

Formats the value using the given formatter. Read more

** =impl<T> Default for Option<T>=

*** =fn default() -> Option<T>=

Returns =None=.

#+BEGIN_SRC rust 
let opt: Option<u32> = Option::default();
assert!(opt.is_none());
#+END_SRC

** =impl<T> Eq for Option<T> where    T: Eq, =

** =impl<'a, T> From<&'a Option<T>> for Option<&'a T>=

*** =fn from(o: &'a Option<T>) -> Option<&'a T>=

Converts from =&Option<T>= to =Option<&T>=.

Converts an =Option<==String==>= into an =Option<==usize==>=, preserving
the original. The =map= method takes the =self= argument by value,
consuming the original, so this technique uses =as_ref= to first take an
=Option= to a reference to the value inside the original.

#+BEGIN_SRC rust 
let s: Option<String> = Some(String::from("Hello, Rustaceans!"));
let o: Option<usize> = Option::from(&s).map(|ss: &String| ss.len());

println!("Can still print s: {:?}", s);

assert_eq!(o, Some(18));
#+END_SRC

** =impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T>=

*** =fn from(o: &'a mut Option<T>) -> Option<&'a mut T>=

Converts from =&mut Option<T>= to =Option<&mut T>=

#+BEGIN_SRC rust 
let mut s = Some(String::from("Hello"));
let o: Option<&mut String> = Option::from(&mut s);

match o {
    Some(t) => *t = String::from("Hello, Rustaceans!"),
    None => (),
}

assert_eq!(s, Some(String::from("Hello, Rustaceans!")));
#+END_SRC

** =impl<T> From<T> for Option<T>=

*** =fn from(val: T) -> Option<T>=

Copies =val= into a new =Some=.

#+BEGIN_SRC rust 
let o: Option<u8> = Option::from(67);

assert_eq!(Some(67), o);
#+END_SRC

** =impl<A, V> FromIterator<Option<A>> for Option<V> where    V: FromIterator<A>, =

*** =fn from_iter<I>(iter: I) -> Option<V> where    I: IntoIterator<Item = Option<A>>, =

Takes each element in the =Iterator=: if it is =None=, no further
elements are taken, and the =None= is returned. Should no =None= occur,
a container with the values of each =Option= is returned.

Here is an example which increments every integer in a vector. We use
the checked variant of =add= that returns =None= when the calculation
would result in an overflow.

#+BEGIN_SRC rust 
let items = vec![0_u16, 1, 2];

let res: Option<Vec<u16>> = items
    .iter()
    .map(|x| x.checked_add(1))
    .collect();

assert_eq!(res, Some(vec![1, 2, 3]));
#+END_SRC

As you can see, this will return the expected, valid items.

Here is another example that tries to subtract one from another list of
integers, this time checking for underflow:

#+BEGIN_SRC rust 
let items = vec![2_u16, 1, 0];

let res: Option<Vec<u16>> = items
    .iter()
    .map(|x| x.checked_sub(1))
    .collect();

assert_eq!(res, None);
#+END_SRC

Since the last element is zero, it would underflow. Thus, the resulting
value is =None=.

Here is a variation on the previous example, showing that no further
elements are taken from =iter= after the first =None=.

#+BEGIN_SRC rust 
let items = vec![3_u16, 2, 1, 10];

let mut shared = 0;

let res: Option<Vec<u16>> = items
    .iter()
    .map(|x| { shared += x; x.checked_sub(2) })
    .collect();

assert_eq!(res, None);
assert_eq!(shared, 6);
#+END_SRC

Since the third element caused an underflow, no further elements were
taken, so the final value of =shared= is 6 (= =3 + 2 + 1=), not 16.

** =impl<T> Hash for Option<T> where    T: Hash, =

=fn hash<__H>(&self, state: &mut __H) where    __H: Hasher, = 

Feeds this value into the given [=Hasher=]. Read more

=fn hash_slice<H>(data: &[Self], state: &mut H) where    H: Hasher, = 

Feeds a slice of this type into the given [=Hasher=]. Read more

** =impl<T> IntoIterator for Option<T>=

*** =type Item = T=

The type of the elements being iterated over.

*** =type IntoIter = IntoIter<T>=

Which kind of iterator are we turning this into?

*** =fn into_iter(self) -> IntoIter<T>=

Returns a consuming iterator over the possibly contained value.

#+BEGIN_SRC rust 
let x = Some("string");
let v: Vec<&str> = x.into_iter().collect();
assert_eq!(v, ["string"]);

let x = None;
let v: Vec<&str> = x.into_iter().collect();
assert!(v.is_empty());
#+END_SRC

** =impl<'a, T> IntoIterator for &'a Option<T>=

*** =type Item = &'a T=

The type of the elements being iterated over.

*** =type IntoIter = Iter<'a, T>=

Which kind of iterator are we turning this into?

=fn into_iter(self) -> Iter<'a, T>= 

Creates an iterator from a value. Read more

** =impl<'a, T> IntoIterator for &'a mut Option<T>=

*** =type Item = &'a mut T=

The type of the elements being iterated over.

*** =type IntoIter = IterMut<'a, T>=

Which kind of iterator are we turning this into?

=fn into_iter(self) -> IterMut<'a, T>= 

Creates an iterator from a value. Read more

** =impl<T> Ord for Option<T> where    T: Ord, =

=fn cmp(&self, other: &Option<T>) -> Ordering= 

This method returns an [=Ordering=] between =self= and =other=. Read
more

=#[must_use]fn max(self, other: Self) -> Self= 

Compares and returns the maximum of two values. Read more

=#[must_use]fn min(self, other: Self) -> Self= 

Compares and returns the minimum of two values. Read more

=#[must_use]fn clamp(self, min: Self, max: Self) -> Self= 

This is a nightly-only experimental API. (=clamp= #44095)

Restrict a value to a certain interval. Read more

** =impl<T> PartialEq<Option<T>> for Option<T> where    T: PartialEq<T>, =

=fn eq(&self, other: &Option<T>) -> bool= 

This method tests for =self= and =other= values to be equal, and is used
by ====. Read more

=fn ne(&self, other: &Option<T>) -> bool= 

This method tests for =!==.

** =impl<T> PartialOrd<Option<T>> for Option<T> where    T: PartialOrd<T>, =

=fn partial_cmp(&self, other: &Option<T>) -> Option<Ordering>= 

This method returns an ordering between =self= and =other= values if one
exists. Read more

=fn lt(&self, other: &Option<T>) -> bool= 

This method tests less than (for =self= and =other=) and is used by the
=<= operator. Read more

=fn le(&self, other: &Option<T>) -> bool= 

This method tests less than or equal to (for =self= and =other=) and is
used by the =<== operator. Read more

=fn gt(&self, other: &Option<T>) -> bool= 

This method tests greater than (for =self= and =other=) and is used by
the =>= operator. Read more

=fn ge(&self, other: &Option<T>) -> bool= 

This method tests greater than or equal to (for =self= and =other=) and
is used by the =>== operator. Read more

** =impl<T, U> Product<Option<U>> for Option<T> where    T: Product<U>, =

*** =fn product<I>(iter: I) -> Option<T> where    I: Iterator<Item = Option<U>>, =

Takes each element in the =Iterator=: if it is a =None=, no further
elements are taken, and the =None= is returned. Should no =None= occur,
the product of all elements is returned.

** =impl<T> StructuralEq for Option<T>=

** =impl<T> StructuralPartialEq for Option<T>=

** =impl<T, U> Sum<Option<U>> for Option<T> where    T: Sum<U>, =

*** =fn sum<I>(iter: I) -> Option<T> where    I: Iterator<Item = Option<U>>, =

Takes each element in the =Iterator=: if it is a =None=, no further
elements are taken, and the =None= is returned. Should no =None= occur,
the sum of all elements is returned.

This sums up the position of the character 'a' in a vector of strings,
if a word did not have the character 'a' the operation returns =None=:

#+BEGIN_SRC rust 
let words = vec!["have", "a", "great", "day"];
let total: Option<usize> = words.iter().map(|w| w.find('a')).sum();
assert_eq!(total, Some(5));
#+END_SRC

** =impl<T> Try for Option<T>=

*** =type Ok = T=

This is a nightly-only experimental API. (=try_trait= #42327)

The type of this value when viewed as successful.

*** =type Error = NoneError=

This is a nightly-only experimental API. (=try_trait= #42327)

The type of this value when viewed as failed.

=fn into_result(self) -> Result<T, NoneError>= 

This is a nightly-only experimental API. (=try_trait= #42327)

Applies the "?" operator. A return of =Ok(t)= means that the execution
should continue normally, and the result of =?= is the value =t=. A
return of =Err(e)= means that execution should branch to the innermost
enclosing =catch=, or return from the function. Read more

=fn from_ok(v: T) -> Option<T>= 

This is a nightly-only experimental API. (=try_trait= #42327)

Wrap an OK value to construct the composite result. For example,
=Result::Ok(x)= and =Result::from_ok(x)= are equivalent. Read more

=fn from_error(NoneError) -> Option<T>= 

This is a nightly-only experimental API. (=try_trait= #42327)

Wrap an error value to construct the composite result. For example,
=Result::Err(x)= and =Result::from_error(x)= are equivalent. Read more

* Auto

** =impl<T> RefUnwindSafe for Option<T> where    T: RefUnwindSafe, =

** =impl<T> Send for Option<T> where    T: Send, =

** =impl<T> Sync for Option<T> where    T: Sync, =

** =impl<T> Unpin for Option<T> where    T: Unpin, =

** =impl<T> UnwindSafe for Option<T> where    T: UnwindSafe, =

* Blanket

** =impl<T> Any for T where    T: 'static + ?Sized, =

=fn type_id(&self) -> TypeId= 

Gets the =TypeId= of =self=. Read more

** =impl<T> Borrow<T> for T where    T: ?Sized, =

=fn borrow(&self) -> &T= 

Immutably borrows from an owned value. Read more

** =impl<T> BorrowMut<T> for T where    T: ?Sized, =

=fn borrow_mut(&mut self) -> &mut T= 

Mutably borrows from an owned value. Read more

** =impl<T> From<!> for T=

=fn from(t: !) -> T= 

Performs the conversion.

** =impl<T> From<T> for T=

=fn from(t: T) -> T= 

Performs the conversion.

** =impl<T, U> Into<U> for T where    U: From<T>, =

=fn into(self) -> U= 

Performs the conversion.

** =impl<I> IntoIterator for I where    I: Iterator, =

*** =type Item = <I as Iterator>::Item=

The type of the elements being iterated over.

*** =type IntoIter = I=

Which kind of iterator are we turning this into?

=fn into_iter(self) -> I= 

Creates an iterator from a value. Read more

** =impl<T> ToOwned for T where    T: Clone, =

*** =type Owned = T=

The resulting type after obtaining ownership.

=fn to_owned(&self) -> T= 

Creates owned data from borrowed data, usually by cloning. Read more

=fn clone_into(&self, target: &mut T)= 

This is a nightly-only experimental API. (=toowned_clone_into= #41263)
recently added

Uses borrowed data to replace owned data, usually by cloning. Read more

** =impl<T, U> TryFrom<U> for T where    U: Into<T>, =

*** =type Error = Infallible=

The type returned in the event of a conversion error.

=fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error>= 

Performs the conversion.

** =impl<T, U> TryInto<U> for T where    U: TryFrom<T>, =

*** =type Error = <U as TryFrom<T>>::Error=

The type returned in the event of a conversion error.

=fn try_into(self) -> Result<U, <U as TryFrom<T>>::Error>= 

Performs the conversion.
